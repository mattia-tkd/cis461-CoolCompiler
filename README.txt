Nicholas Chaimov
CIS 461
Jan 11th, 2010

To build, run make.
To run the scanner only, run scan <filename>.
To run the parser, run parse <filename>.

















This is a "starter kit" for your scanner.  The main files you will need
to work on are: 

  - Cup.jflex

    I've defined a lot of the patterns for you already, but left a few 
    for you to fill in.  Punctuation and keywords are trivial --- all you 
    need to understand is how to match up their names with names used 
    by the parser. The file sym.java has a complete list of tokens, so 
    it's easy to see what's missing.    

    Although I included patterns for comments and strings, these are
    untested. I think there is a reasonable chance the comment pattern
    is correct. It's unlikely the string literal pattern is correct ... 
    what a hairball.  You can try to write a correct regular expression 
    for it, or you can break it down using lexical states, following the
    example of the comment pattern.  If you google around, you'll probably 
    find lots of examples of regular expressions for quoted strings, and 
    you might be able to tweak one of them to work. 

- Tests

  What are here are mostly from a fall semester class at Stanford, where
  they used the Cool language as Aiken defined it.  Our version is a little
  different, so at least some of these will need editing before they are 
  good test cases for your scanner. The keywords test case includes a
  bunch of keywords in lower case (these should be recognized by your
  scanner) and a bunch in upper and mixed case (these should be rejected by
  your scanner).  I strongly suggest writing some additional, very small
  test cases. You should have: 
     - a test case that includes every lexical token in Cool, as a 
       completeness check. It doesn't have to be a legal Cool program. 
     - test cases that torture the hard parts of the scanner, which are
       primarily strings and comments. 

- scan

  This is a trivial shell script to make it slightly less painful to type
  the command to run the driver.  If you're on any sort of *nix machine,
  including Solaris, Linux, or MacOS, it will probably run as-is.  If you're
  on BeOS, Atari, PalmOS, ... or maybe even Windows, if any of you use that
  ... then you'll probably need to rewrite it. 

Other stuff you'll find here: 

    sym.java was generated by Cup, from a parser definition that I've
    removed.  You can tell Cool was written before Java had enum. 

    symNames.java was generated by the awk script tokenNames.awk in the
    tools subdirectory. 

    ScanDriver.java is what you'll run to test your scanner.  It's a
    stripped down version of a driver I used to test a parser. 

    Symbolx.java is the class for Cool tokens.  It's there largely to fix 
    some issues in the Symbol class provided by Cup, which keeps track 
    of the byte position in a source file rather than the line and column.

    ErrorReport.java just shovels error messages out to stderr. It should
    probably do more, but it can't do any of the work that depends on
    knowing about internal state in the parser or scannner. 

    lib contains libraries used now and some that we'll use later (such as
    the string template library from Antlr).  

    Makefile is here because I dislike Ant (an example of a tool that could
    be improved by including a parser, but it has other problems too) and
    because I haven't learned to use Maven.  If you use it, you'll have to
    tell it where you installed JFlex. 

What to turn in: 
     If you're using Java, the simplest thing is to zip this directory back
     up, include a README that identifies you, and give me that ... as
     self-contained as possible.  If you switch from Make to some more
     modern build system, please make sure there is a way for *me* to build
     your project without installing whatever tools you use. 

     If you're not using Java ... then you need to build the functional
     equivalent of this, and somehow package it up with nice documentation
     so that I can understand how to build and run it, either on Solaris
     (ix) or on a MacOS 10.5 machine. 


